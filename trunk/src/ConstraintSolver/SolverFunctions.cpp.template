/****************************************************************************
**
** This file is part of the pSketcher project.
**
** This file may be used under the terms of the GNU General Public
** License version 2.0 as published by the Free Software Foundation
** and appearing in the file LICENSE.GPL included in the packaging of
** this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** Copyright (C) 2006-2009 Michael Greminger. All rights reserved.
**
****************************************************************************/

#include <cmath>

#include "SolverFunctions.h"

using namespace std;
<%!
from sympy import ccode
%>

SolverFunctionsBasePointer SolverFunctionsFactory(std::string solver_function_name, std::vector<DOFPointer> dof_list)
{
    SolverFunctionsBasePointer new_solver_function;

%for index,equation in enumerate(equations):
    %if index == 0:
    if(solver_function_name == "${equation.function_name}")
        new_solver_function.reset(new ${equation.function_name}(dof_list));
    %else:
    else if (solver_function_name == "${equation.function_name}")
        new_solver_function.reset(new ${equation.function_name}(dof_list));
    %endif
%endfor
    else
        throw SolverFunctionsException("SolverFunctionsFactory: Requested solver function name not found.");

    return new_solver_function;
}

%for equation in equations:

${equation.function_name}::${equation.function_name}(${make_parameter_list(equation.parameter_list)})
{
    %for parameter in equation.parameter_list:
    AddDOF(${parameter});
    %endfor
}

${equation.function_name}::${equation.function_name}(std::vector<DOFPointer> dof_list)
{
    // Check to make sure the correct number of parameters have been provided
    if(dof_list.size() != ${len(equation.parameter_list)})
        throw SolverFunctionsException("The DOF vector for the constructor of SolverFunction ${equation.function_name} did not contain exactly ${len(equation.parameter_list)} DOF's");
    
    for(int i=0; i<dof_list.size(); i++)
        AddDOF(dof_list[i]);
}

double ${equation.function_name}::GetValue() const
{
    %for index,parameter in enumerate(equation.parameter_list):
    double ${parameter} = GetDOF(${index})->GetValue();
    %endfor

    return ${ccode(equation.expression)};
}

double ${equation.function_name}::GetValueSelf(const mmcMatrix &params) const
{
    %for index,parameter in enumerate(equation.parameter_list):
    double ${parameter} = params(${index},0);
    %endfor

    return ${ccode(equation.expression)};
}

mmcMatrix ${equation.function_name}::GetGradientSelf(const mmcMatrix &params) const
{
    mmcMatrix result(GetNumDOFs(),1);

    %for index,parameter in enumerate(equation.parameter_list):
    double ${parameter} = params(${index},0);
    %endfor

    %for index,parameter in enumerate(equation.parameter_list):
    result(${index},0) = ${ccode(equation.expression.diff(parameter))};
    %endfor

    return result;
}
%endfor

<%def name="make_parameter_list(parameter_list)">\
% for index,parameter in enumerate(parameter_list):
DOFPointer ${parameter}\
        % if index < len(parameter_list)-1:
, \
        % endif
    % endfor
</%def>